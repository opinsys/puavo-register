#!/usr/bin/env ruby
#
# Puavo Devices Client Install
# * simple command-line script for registering devices
#   to the Puavo Devices Server and installing them
#
# TODO
# * localization by user settings and by operating system default locale?
# * how to ask device information that is not required
#   (latitude, longitude, description etc.)?
#
# suggestion: run this as:
#   script -qc ./puavo-client-register /root/register.log

require 'facter'
require 'fileutils'
require 'highline/import'
require 'json'
require 'net/https'
require 'openssl'
require 'resolv'
require 'socket'
require 'yaml'

Puavodir = '/etc/puavo'

HostCrtPath     = "#{ Puavodir }/certs/host.crt"
HostKeyPath     = "#{ Puavodir }/certs/host.key"
OrgCABundlePath = "#{ Puavodir }/certs/orgcabundle.pem"
RootCAPath      = "#{ Puavodir }/certs/rootca.pem"

Host_configuration_path = "#{ Puavodir }/host_configuration"

class Tools
  def self.colormsg(msg, tag, color)
    HighLine.say(HighLine.new.color("*** #{ tag }: #{ msg }", color))
  end

  def self.errmsg(msg) ; colormsg(msg, 'ERROR', HighLine::RED)  ; end
  def self.goodmsg(msg); colormsg(msg, 'OK',    HighLine::GREEN); end

  def self.mkdir(path, mode=0755)
    begin
      FileUtils.mkdir(path, :mode => mode)
      rescue Errno::EEXIST
    end
  end

  def self.topdomain(domain)
    domain.match(/[^\.]+\.[^\.]+$/).to_s
  end

end

class CmdLine
  def self.params(cmd_args)
    params = {}
    new_arg = nil

    cmd_args.each do |i|
      case i
        when /^--(   force
                   | install
                   | netboot
                   | noconfirm
                   | noinstall
                   | register
                   | setup-openvpn )$/x
          params[$1] = true
        else
          if new_arg.nil?
            new_arg = i
          else
            params[ new_arg.match(/^--(.*)$/)[1] ] = i
            new_arg = nil
          end
      end
    end

    params
  end
end

class HttpAuthError < Exception; end

class HostCertificate
  def initialize
    @key = OpenSSL::PKey::RSA.new(1024)
    @csr = OpenSSL::X509::Request.new
    @csr.version = 0
    @csr.public_key = @key.public_key
  end

  def accept_signed_certificate(certificate, rootca, orgcabundle)
    @crt         = OpenSSL::X509::Certificate.new(certificate)
    @rootca      = rootca
    @orgcabundle = orgcabundle
  end

  def fqdn
    self.class.fqdn_from_cert(@crt)
  end

  def self.fqdn_from_cert(cert)
    ((/^.*CN=(.*?)(\/|$)/.match(cert.subject.to_s))[1])
  end

  def request
    @csr.to_pem
  end

  def write_to_filesystem(certpath, keypath, rootcapath, orgcabundlepath)
    File.open(certpath,        'w', 0444) { |f| f.print @crt.to_pem  }
    File.open(keypath,         'w', 0400) { |f| f.print @key.to_pem  }
    File.open(rootcapath,      'w', 0444) { |f| f.print @rootca      }
    File.open(orgcabundlepath, 'w', 0444) { |f| f.print @orgcabundle }

    Tools.goodmsg('Certificates have been written to filesystem.')
  end
end

class RegisterUserInterface

  attr_accessor :responses, :connection

  def initialize(cmdline_params, cert)
    @responses       = {}
    @cmdline_params  = cmdline_params

    @mode = {
      'boottype'  => @cmdline_params['netboot'] ? 'net' : 'local',
      'noconfirm' => @cmdline_params['noconfirm'],
      'noinstall' => @cmdline_params['noinstall'],
    }

    @puavoserver     = @cmdline_params['puavoserver'] || default_puavoserver()
    @username        = @cmdline_params['username']
    @password        = @cmdline_params['password']

    facts = Facter.to_hash

    @system_defaults = {
      'host_certificate_request' => cert.request,
      'macAddress'               => lookup_macaddresses(facts),
      'puavoDeviceManufacturer'  => facts['manufacturer'],
      'puavoDeviceModel'         => facts['productname'],
      'puavoHostname'            => facts['hostname'],
      'serialNumber'             => facts['serialnumber'],
    }

    @host = {}
  end

  def ask_devicetype()
    @responses['devicetype'] =
      choicelist(@connection.devicetypes['list'],
                 'devicetype',
                 @connection.devicetypes['title'],
                 @connection.devicetypes['question'])

    @attributes = request_attributes(@responses['devicetype'])

    set_host_attributes()
  end

  def show_disk_devices(disk_devices)
    sleep(1.5)
    disk_devices.each do |device|
      system("fdisk -l /dev/#{ device } | more") \
        or raise "Error running fdisk for device '#{ device }'"
    end
  end

  def ask_installation_info()
    info = {}

    if @host['devicetype'] == 'laptop'
      info['diskdevice'] = ask_diskdevice()
      info['partition']  = ask_partition(info['diskdevice'])
    end

    info
  end

  def ask_diskdevice()
    disk_devices = []

    chosen_disk_device = nil
    until disk_devices.include?(chosen_disk_device) do
      disk_devices = %x(partprobe -ds) \
                     .split("\n") \
                     .map { |s| s.split(":")[0] } \
                     .map { |s| (s.match(%r{^/dev/(.*)}))[1] } \
                     .compact

      puts '-----'
      puts "This machine has the following disk devices:\n"
      show_disk_devices(disk_devices)

      if chosen_disk_device.nil?
        chosen_disk_device = disk_devices[0]
      end

      puts "\nPossible disk devices are: #{ disk_devices.join(' ') }"
      chosen_disk_device = ask_with_default('Choose a disk device:',
                                    chosen_disk_device)
    end

    chosen_disk_device
  end

  def ask_partition(disk_device)
    partitions = []

    chosen_partition = 'whole'
    until partitions.include?(chosen_partition) do
      if chosen_partition == 'cfdisk'
        system('cfdisk', "/dev/#{ disk_device }")
        chosen_partition = 'whole'
      end

      puts '-----'
      puts "The disk /dev/#{ disk_device } has the following partitions:\n"
      show_disk_devices(disk_device)

      partitions \
        = %w(whole) \
          + IO.readlines('/proc/partitions') \
              .map { |line| (line.split)[3] } \
              .compact \
              .select { |part| part.match(/^#{ disk_device }[0-9]/) } \

      puts "\nPossible partitions are: #{ partitions.join(' ') }"
      puts "You may choose 'cfdisk' to partition this disk,"
      puts "or choose 'whole' to use the whole disk."
      chosen_partition = ask_with_default('Choose a partition:',
                                          chosen_partition)
    end

    chosen_partition
  end

  def ask_machine_info(errors={}, ask_all=true)
    unhandled = errors.clone

    if ask_all
      ask_devicetype()
      ask_school() if school_required?
    end

    @attributes.each do |attr|
      field = attr['id']

      next unless ask_all or unhandled[field]
      next if attr['label'].empty?
      next if %(devicetype school).include?(field)

      if unhandled[field] and not ask_all
        Tools.errmsg(unhandled[field])
        unhandled.delete(field)
      end

      question = attr['label'] + ':'
      @responses[field] = ask_with_default(question, @host[field])

      set_host_attributes()
    end

    unhandled.each do |field, errmsg|
      Tools.errmsg("Server reported unhandled error for #{ field }: " \
                   + errmsg)
    end
  end

  def ask_school()
    list = @connection.schools['list']

    @responses['school'] \
      = list.size == 1 ? list.keys[0] \
      : choicelist(@connection.schools['list'],
                   'school',
                   @connection.schools['title'],
                   @connection.schools['question'])

    @attributes = request_attributes(@responses['devicetype'],
                             @responses['school'])

    set_host_attributes()
  end

  def ask_with_default(question, default)
    prompt = "#{ question } [#{ default }] "
    answer = HighLine.ask(prompt) { |q| q.whitespace = nil }

    return answer.match(/^\n$/)  ? default \
         : answer.match(/^\s+$/) ? ''      \
         : answer.strip
  end

  def choicelist(items, field, header, prompt)
    selected = nil
    itemkeys = items.keys.sort_by { |i| items[i]['order'] }

    choose do |menu|
      itemkeys.each do |id|
        menu.choice(items[id]['label']) { selected = id }
      end
      if @host.has_key?(field)
        menu.prompt = prompt + "[#{ items[ @host[field] ]['label'] }] "
        menu.hidden('') { selected = @host[field] }
      else
        menu.prompt = prompt
      end
      menu.header = header
    end

    HighLine.say "===> selected [#{ items[selected]['label'] }]"

    selected
  end

  def connect_to_puavo()
    if (@puavoserver and @username and @password)
      @connection = puavo_connection_request()
    else
      until (@connection)
        begin
          begin
            @puavoserver = ask_with_default('Puavo server name:', @puavoserver)
            @connection  = PuavoDevicesConnection.new(@puavoserver, '', '', '')
          rescue HttpAuthError
          end
          @username   = ask_with_default('Username:', @username)
          @password   = HighLine.ask('Password: ') { |q| q.echo = '*' }
          @connection = puavo_connection_request()
        rescue HttpAuthError
          Tools.errmsg('Wrong username and/or password.')
          @http = nil
        rescue SocketError => e
          Tools.errmsg(e)
          @http = nil
        end
      end
    end
  end

  def default_puavoserver
    begin
      Resolv::DNS.open do |dns|
        r = dns.getresources('_puavo._tcp', Resolv::DNS::Resource::IN::SRV)
        r[0].target.to_s
      end
    rescue
      Tools.errmsg('Could not lookup default puavoserver.')
    end
  end

  def lookup_macaddresses(facts)
    facts['interfaces'].split(',').
                        map { |intf| facts["macaddress_#{intf}"] }.
                        compact.sort.uniq.join(' ')
  end

  def print_machine_info
    set_host_attributes()
    HighLine.say "\nHOST INFORMATION:"

    @attributes.each do |attr|
      next if attr['label'].empty?
      field = attr['id']
      value =
        case field
          when 'devicetype'
            @connection.devicetypes['list'][ @host[field] ]['label']
          when 'school'
            next unless school_required?
            @connection.schools['list'][ @host[field] ]['label']
          else
            @host[field]
        end
      printf("%-24s%s\n", attr['label'] + ': ', value)
    end

    print "\n"
  end

  def puavo_connection_request()
    PuavoDevicesConnection.new(@puavoserver,
                               @username,
                               @password,
                               @mode['boottype'])
  end

  def register_to_server
    connect_to_puavo()

    @attributes = request_attributes(@cmdline_params['devicetype'],
                                     @cmdline_params['school'])

    info = {}

    loop do
      print_machine_info()

      until @mode['noconfirm'] or agree('Is this information correct? (y/n) ')
        ask_machine_info()
        print_machine_info()
      end

      unless @mode['noinstall']
        info['installation'] = ask_installation_info()
      end

      HighLine.say 'Sending host information to puavo server...'
      response_data = @connection.post_host(@host)
      if response_data['register_info']
        if @host['host_certificate_request'] \
          and not response_data['register_info']['userCertificate']
            Tools.errmsg('Server did not send a signed certificate.')
        else
          info['registration'] = response_data['register_info']
          Tools.goodmsg('This machine is now successfully registered.')

          break
        end
      else
        ask_machine_info(response_data['errors'], false)
      end
    end

    info
  end

  def request_attributes(devicetype=nil, school=nil)
    devicetype ||= @host['devicetype']
    school     ||= @host['school']
    @connection.request_object_info(devicetype, school)
  end

  def school_required?
    @connection.devicetypes['list'][ @host['devicetype'] ]['school_required']
  end

  def set_host_attributes
    @host = {}
    @attributes.each do |attr|
      next if attr['id'] == 'school' and not school_required?
      @host[ attr['id'] ] = @responses[       attr['id'] ] ||
                            @cmdline_params[  attr['id'] ] ||
                            attr['default']                ||
                            @system_defaults[ attr['id'] ] ||
                            ''
    end
  end
end

class PuavoDevicesConnection
  attr_accessor :devicetypes, :schools

  def initialize(server, username, password, boottype)
    @server   = server
    @username = username
    @password = password

    devicetypes_url = "/devices/hosts/types.json?boottype=#{ boottype }"

    @http              = Net::HTTP.new(server, '443')
    @http.use_ssl      = true
    @http.ca_path      = '/etc/ssl/certs'
    @http.verify_mode  = OpenSSL::SSL::VERIFY_PEER
    @http.verify_depth = 5
    @devicetypes       = get(devicetypes_url)

    userinfo = get('/devices/sessions/show.json')
    @schools = userinfo['managed_schools'].clone
    @schools['list'] = Hash[
      userinfo['managed_schools']['list'].map do |school|
        [
          school['puavoId'].to_s,
          {
            'label' => school['displayName'],
            'order' => school['puavoId'],
          },
        ]
      end
    ]
  end

  def request_object_info(devicetype, school)
    devicetype = devicetype || @devicetypes['default'].to_s
    school     = school     || @schools['default'].to_s
    # put school id into url if %s exists in url string
    question_url = @devicetypes['list'][ devicetype ]['url'] % school

    form = get(question_url)
    @post_info = {
      'object_key' => form['object_key'],
      'url'        => form['url'] % school,
    }

    [
      {
        'default' => @devicetypes['default'].to_s,
        'id'      => 'devicetype',
        'label'   => @devicetypes['label'],
      },
      {
        'default' => @schools['default'].to_s,
        'id'      => 'school',
        'label'   => @schools['label'] },
    ] + form['attributes'] 
  end

  def get(url)
    @http.start do |http|
      request = Net::HTTP::Get.new(url)
      request.basic_auth(@username, @password)
      response = http.request(request)
      if response.class == Net::HTTPUnauthorized
        raise HttpAuthError
      end
      JSON.parse(response.body)
    end
  end

  def host_to_json(host)
    {
      @post_info['object_key'] => Hash[
        host.map do |key, value|
          [
            key,
            (key == 'macAddress' ? value.split(' ') : value)
          ]
        end
      ]
    }.to_json
  end

  def post_host(host)
    request = Net::HTTP::Post.new(@post_info['url'],
                                  { 'Content-Type' => 'application/json' })
    request.basic_auth(@username, @password)
    response = @http.request(request, host_to_json(host))
    case response.code
      when /^2/
        # successful request
        Hash[ 'errors' => {}, 'register_info' => JSON.parse(response.body), ]
      when /^5/
        Tools.errmsg("Server response is #{ response.code }: " \
                     + response.message)
        Hash[ 'errors' => {} ]
      else
        Hash[ 'errors' => Hash[ JSON.parse(response.body) ] ]
    end
  end
end


# Post Registration operations. Writes registration information to /etc/puavo
module PostRegister

  def self.ensure_puavodir
    Tools.mkdir(Puavodir)
  end

  def self.write_hostname(hostname)
    ensure_puavodir

    File.open("#{ Puavodir }/hostname", 'w', 0644) do |f|
      f.print "#{ hostname }\n"
    end
  end

  def self.write_domain(domain)
    ensure_puavodir

    File.open("#{ Puavodir }/domain", 'w', 0644) do |f|
      f.print "#{ domain }\n"
    end

    File.open("#{ Puavodir }/topdomain", 'w', 0644) do |f|
      f.print "#{ Tools.topdomain(domain) }\n"
    end

  end

  def self.write_ldap_info(dn, password, base, master)
    ensure_puavodir
    Tools.mkdir(Puavodir + "/ldap")

    File.open("#{ Puavodir }/ldap/dn", 'w', 0644) do |f|
      f.print "#{ dn }\n"
    end

    File.open("#{ Puavodir }/ldap/base", 'w', 0644) do |f|
      f.print "#{ base }\n"
    end

    File.open("#{ Puavodir }/ldap/master", 'w', 0644) do |f|
      f.print "#{ master }\n"
    end

    File.open("#{ Puavodir }/ldap/password", 'w', 0600) do |f|
      f.print "#{ password }\n"
    end

    Tools.goodmsg('LDAP information is now set.')
  end

  def self.write_kerberos_info(realm, master)
    ensure_puavodir
    Tools.mkdir(Puavodir + "/kerberos")

    File.open("#{ Puavodir }/kerberos/realm", 'w', 0644) do |f|
      f.print "#{ realm }\n"
    end

    File.open("#{ Puavodir }/kerberos/toprealm", 'w', 0644) do |f|
      f.print "#{ Tools.topdomain(realm) }\n"
    end

    File.open("#{ Puavodir }/kerberos/master", 'w', 0644) do |f|
      f.print "#{ master }\n"
    end

    Tools.goodmsg('Kerberos information is now set.')
  end

  def self.write_host_configuration(conf)
    ensure_puavodir
    File.open(Host_configuration_path, 'w') do |f|
      f.print conf.to_yaml
    end
    Tools.goodmsg('Host configuration file is written.')
  end
end

class Installation
  def self.fqdn
    hostcrt = IO.read("#{ Puavodir }/certs/host.crt")
    cert = OpenSSL::X509::Certificate.new(hostcrt)
    HostCertificate.fqdn_from_cert(cert)
  end

  def self.install
    conf = YAML.load_file(Host_configuration_path)

    fqdn = fqdn()

    todo_lists = {
      'fatclient'  => %w(),
      'infotv'     => %w(check_root_password hostname openvpn puppet),
      'laptop'     => %w(install_ltspimages setup_grub              ),
      'ltspserver' => %w(check_root_password hostname openvpn puppet),
      'thinclient' => %w(),
    }

    tasks = {
      'check_root_password' => lambda { make_sure_root_password_is_set()    },
      'hostname'            => lambda { Setup.hostname(fqdn)                },
      'install_ltspimages'  => lambda { Setup.install_ltspimages(conf)  },
      'openvpn'             => lambda { Setup.openvpn()                     },
      'puppet'              => lambda { Setup.puppet(conf['puppet_server'],
                                                     fqdn)                  },
      'setup_grub'          => lambda { Setup.setup_grub(conf)              },
    }

    my_todo_list = todo_lists[ conf['devicetype'] ]
    raise 'No installation todo-list for device type ' \
          + "'#{ conf['devicetype'] }'" \
      unless my_todo_list

    my_todo_list.each { |taskname| tasks[taskname].call() }
  end

  def self.make_sure_root_password_is_set
     unless %x(passwd -S root).split[1] == 'P' then
       Tools.errmsg('root password is not usable.')
       Tools.errmsg('Please set it and run this again.')
       raise 'root password is not usable'
     end
  end

  def self.run_puppet(opts='')
    unless system('puppetd --test --logdest console' +
                  " --logdest /var/log/puppet/install.log #{ opts }")
      raise 'problem running puppetd'
    end
  end
end

class Setup
  def self.hostname(fqdn)
    hostname = fqdn.split('.')[0]

    begin
      File.open('/etc/hostname', 'w') do |f|
        f.print "#{ hostname }\n"
      end
      unless system('hostname --file /etc/hostname')
        raise 'could not set hostname'
      end
    rescue Exception => e
      Tools.errmsg(e.message)
      raise e
    end

    Tools.goodmsg("System hostname is now set to #{ hostname }.")
  end

  def self.kerberos(principals)
    return # XXX this method is not used yet

    begin
      error = false
      principal = HighLine.ask("\nKerberos principal: ")
      password  = HighLine.ask('Password: ') { |q| q.echo = '*' }

      principals.each do |princ|
        goodmsg, errmsg = [], []
        Open3.popen3('kadmin', '-p', principal, '-w', password, '-q',
                     "add_principal #{ princ }") do |stdin, stdout, stderr|
          goodmsg = stdout.readlines
          errmsg  = stderr.readlines
        end
        # XXX use some criteria to figure out if operation was ok
        status = $?.exitstatus
        Tools.errmsg("exit status is #{ status }")
        goodmsg.each { |l| Tools.goodmsg(l.chomp) }
        errmsg .each { |l| Tools.errmsg(l.chomp)  }
        error = true
        break
      end
    end while error
  end


  def self.openvpn(restart_and_wait=true)
    begin
      Tools.mkdir('/etc/openvpn/keys')

      ovpn_crt         = '/etc/openvpn/keys/host.crt'
      ovpn_key         = '/etc/openvpn/keys/host.key'
      ovpn_orgcabundle = '/etc/openvpn/keys/orgcabundle.pem'

      FileUtils.cp(HostCrtPath,     ovpn_crt)
      FileUtils.cp(HostKeyPath,     ovpn_key)
      FileUtils.cp(OrgCABundlePath, ovpn_orgcabundle)

      File.open('/etc/openvpn/runme', 'w', 0755) do |f|
        f.print <<-EOF.gsub(/^\t+/, '')
		#!/bin/sh

		SCRIPTSUBDIR=$1

		for script in /etc/openvpn/scripts/$SCRIPTSUBDIR/*; do
		  test -x $script && timeout 30 $script "$@"
		done

		exit 0
		EOF
      end
      File.open('/etc/openvpn/puavoclient.conf', 'w', 0644) do |f|
        f.print <<-EOF.gsub(/^\t+/, '')
		client
		dev tun
		proto tcp-client
		remote 217.112.254.13 443

		ca #{ ovpn_orgcabundle }
		cert #{ ovpn_crt }
		key #{ ovpn_key }
		ns-cert-type server

		verb 3

		comp-lzo
		keepalive 10 60
		persist-tun
		persist-key

		up-delay
		script-security 2

		down "/etc/openvpn/runme down"
		ipchange "/etc/openvpn/runme ipchange"
		route-up "/etc/openvpn/runme route-up"
		tls-verify "/etc/openvpn/runme tls-verify"
		up "/etc/openvpn/runme up"
		EOF
      end

      if restart_and_wait
        unless system('service openvpn restart')
          raise 'problem restarting openvpn'
        end

        sleep 2
        until system('ifconfig tun0 >/dev/null 2>&1')
          Tools.errmsg('waiting for tun0 to come up...')
          sleep 2
        end
        sleep 2
      end

    rescue Exception => e
      Tools.errmsg(e.message)
      raise e
    end
    Tools.goodmsg('OpenVPN setup is done.')
  end

  def self.manage_local(diskdevice, partition, opmode)
    system('manage_local_ltspclient_installation',
           opmode,
           diskdevice,
           partition) \
      or raise "Error doing install operation #{ opmode }"
  end

  def self.install_ltspimages(conf)
    manage_local(conf['diskdevice'], conf['partition'], 'install')
  end

  def self.prepare_laptop_disk(conf)
    diskdevice = conf['diskdevice']
    partition  = conf['partition']

    install_phases = []

    if partition == 'whole'
      install_phases = %w(lvm_partition liitu_partitions)
      partition      = "#{ diskdevice }1"
    else
      install_phases = %w(liitu_partitions)
    end

    install_phases.each do |opmode|
      manage_local(diskdevice, partition, opmode)
    end

    FileUtils.mkdir_p('/disk/state')
    system('mount', '/dev/mapper/liito-state', '/disk/state') \
      or raise 'Could not mount /dev/mapper/liito-state'
    FileUtils.mkdir_p("/disk/state#{ Puavodir }")
    system('mount', '-o', 'bind', "/disk/state#{ Puavodir }", Puavodir) \
      or raise 'Could not mount /dev/mapper/liito-state'
  end

  def self.setup_grub(conf)
    raise 'Grub install is supported only on laptops' \
      if conf['devicetype'] != 'laptop'

    system('vgrename', 'liito', 'liitu') \
      or raise 'Could not rename the lvm volume group'
    manage_local(conf['diskdevice'], conf['partition'], 'grubinstall')
  end

  def self.puppet(puppet_server, fqdn)
    raise 'Puppet server is not known' \
      unless puppet_server && !puppet_server.empty?

    raise 'FQDN is not known' unless fqdn && !fqdn.empty?

    begin
      # needed by some facter rules
      FileUtils.rmtree('/etc/puppet/ssl')
      Tools.mkdir('/etc/puppet/ssl',              0771)
      Tools.mkdir('/etc/puppet/ssl/certs')
      Tools.mkdir('/etc/puppet/ssl/private_keys', 0750)
      FileUtils.chown('puppet', 'root', [ '/etc/puppet/ssl',
                                          '/etc/puppet/ssl/certs',
                                          '/etc/puppet/ssl/private_keys', ])

      FileUtils.cp(HostCrtPath, "/etc/puppet/ssl/certs/#{ fqdn }.pem")
      FileUtils.cp(HostKeyPath, "/etc/puppet/ssl/private_keys/#{ fqdn }.pem")
      FileUtils.cp(OrgCABundlePath, '/etc/puppet/ssl/certs/ca.pem')

      File.open('/etc/default/puppet', 'w') do |f|
        f.print <<-EOF.gsub(/^\t+/, '')
		START=yes
		DAEMON_OPTS=""
		EOF
      end

      File.open('/etc/puppet/puppet.conf', 'w') do |f|
        f.print <<-EOF.gsub(/^\t+/, '')
		[main]
		certname=#{ fqdn }
		factpath=/var/lib/puppet/lib/facter
		logdir=/var/log/puppet
		pluginsync=true
		postrun_command=/etc/puppet/etckeeper-commit-post
		prerun_command=/etc/puppet/etckeeper-commit-pre
		rundir=/var/run/puppet
		server=#{ puppet_server }
		templatedir=$confdir/templates
		vardir=/var/lib/puppet
		EOF
      end

      Tools.goodmsg('Puppet setup is done, running puppet once...')
      run_puppet('--tags debian::apt::client')
      run_puppet()
      Tools.goodmsg('Puppet run is done.')
      Tools.goodmsg('Check that all is ok, and re-execute this if in doubt.')
    rescue Exception => e
      Tools.errmsg(e.message)
      raise e
    end
  end
end

class Control
  def self.register(cmdline_params)
    if File.exists?(Host_configuration_path) && !cmdline_params['force']
      Tools.errmsg('Registration is already done and --force is not applied.')
      exit 1
    end

    cert = HostCertificate.new

    rui  = RegisterUserInterface.new(cmdline_params, cert)
    info = rui.register_to_server()

    organisation_info = rui.connection.get("/users/organisation.json")
    # org["ldap_host"], org["domain"]

    if cmdline_params['noinstall']
      Tools.goodmsg('Not doing post-registration configuration ' \
                    + '(--noinstall is set)')
      return
    end

    raise 'Did not receive host configuration from Puavo' \
        unless info['registration']['host_configuration']


   if info['registration']['userCertificate']
      raise 'Root CA missing' \
        unless info['registration']['rootca']
      raise 'Organisation CA bundle missing' \
        unless info['registration']['orgcabundle']

      cert.accept_signed_certificate(info['registration']['userCertificate'],
                                      info['registration']['rootca'],
                                      info['registration']['orgcabundle'])

      Tools.mkdir("#{ Puavodir }")
      Tools.mkdir("#{ Puavodir }/certs")
      cert.write_to_filesystem("#{ Puavodir }/certs/host.crt",
                                "#{ Puavodir }/certs/host.key",
                                "#{ Puavodir }/certs/rootca.pem",
                                "#{ Puavodir }/certs/orgcabundle.pem")
    end



    PostRegister.write_ldap_info(
      info['registration']['dn'],
      info['registration']['ldap_password'],
      info['registration']['base'],
      organisation_info['ldap_host']
    )

    PostRegister.write_kerberos_info(
      info['registration']["host_configuration"]["kerberos_realm"],
      # In our architecture kerberos master is always the same as ldap master
      organisation_info['ldap_host']
    )

    PostRegister.write_hostname(rui.responses["puavoHostname"])

    PostRegister.write_domain(organisation_info["domain"])

    PostRegister.write_host_configuration(
      info['registration']['host_configuration'].merge(info['installation'])
    )

  end

  def self.install(cmdline_params)
    if cmdline_params['noinstall']
      Tools.goodmsg('Not doing the installation (--noinstall is set)')
      return
    end

    Installation.install
  end
end

raise 'run me as root' unless Process.uid == 0

HighLine.say "\n\t-=< Puavo Devices Client >=-\n\n"

cmdline_params = CmdLine.params(ARGV)

if cmdline_params['setup-openvpn']
  Setup.openvpn(false)
elsif cmdline_params['register']
  Control.register(cmdline_params)
elsif cmdline_params['install']
  Control.install(cmdline_params)
else
  Control.register(cmdline_params)
  Control.install(cmdline_params)
end
